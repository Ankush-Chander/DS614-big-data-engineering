{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"code/lecture_3_4/","title":"Log based storage engine","text":"<p>This is a simple log based storage engine implementation using FastAPI</p> <p>Source : log_based_storage_engine</p>"},{"location":"code/lecture_3_4/#setup","title":"Setup","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"code/lecture_3_4/#run","title":"Run","text":"<pre><code>uvicorn log_based_main:app --reload\n</code></pre>"},{"location":"code/lecture_3_4/#api","title":"API","text":"<pre><code># set key\ncurl -X POST http://localhost:8000/set_db  -H 'accept: application/json'   -H 'Content-Type: application/json'  --data '{\"key\":\"42\",\"val\":\"life\"}'\n\n# get key\ncurl -X GET http://localhost:8000/get_db/42\n# returns `life`\n\n# update key\ncurl -X POST http://localhost:8000/set_db  -H 'accept: application/json'   -H 'Content-Type: application/json'  --data '{\"key\":\"42\",\"val\":\"answer to life\"}'\n\n# get key\ncurl -X GET http://localhost:8000/get_db/42\n# returns `answer to life`\n\n# inspect database\ncat database.csv\n</code></pre>"},{"location":"lectures/Lecture3_4/","title":"Lecture3_4","text":""},{"location":"lectures/Lecture3_4/#quick-recap","title":"Quick recap","text":"<ul> <li>Data Engineer: skills and responsibilities</li> <li>Data Engineering lifecycle</li> </ul>"},{"location":"lectures/Lecture3_4/#agenda","title":"Agenda","text":"<ul> <li>Revision<ul> <li>System overview</li> <li>Memory hierarchy</li> </ul> </li> <li>Storage engines<ul> <li>Log based storage</li> <li>Hash indexes</li> </ul> </li> </ul>"},{"location":"lectures/Lecture3_4/#why-study-storage-internals","title":"Why study storage internals?","text":"<ul> <li>To pick right tools for your use case</li> <li>To be able to tune the configurations of storage engine as per your requirements</li> </ul>"},{"location":"lectures/Lecture3_4/#storage-engine-overview","title":"Storage engine overview","text":"Property Transaction processing systems(OLTP) Analytics processing(OLAP) Primarily used for End user/customer, via web application Internal analyst, for decision support What data represents Latest state of data (current point in time) History of events that happened over time Dataset size Gigabytes to terabytes Terabytes to petabytes Main write pattern Random-access, low-latency writes from user input Bulk import (ETL) or event stream Main read pattern Small number of records per query, fetched by key Aggregate over large number of records Implementation types - Log structured database- B tree based databases - Columnar storage"},{"location":"lectures/Lecture3_4/#quick-revision","title":"Quick Revision","text":""},{"location":"lectures/Lecture3_4/#system-overview","title":"System overview","text":""},{"location":"lectures/Lecture3_4/#layered-architecture","title":"Layered architecture","text":"<p>  Image credits: CSAPP</p>"},{"location":"lectures/Lecture3_4/#hardware-overview","title":"Hardware overview","text":"<p> Image credits: CSAPP</p> <p>Buses are like nervous system of the computer. Data moves from one place to another via buses. Buses are charecterized by word size as well as bits that can be transfered in a given time.</p> <p>IO devices are what connects a computer to external world. It\"s like humans have 5 senses, computer has IO devices. 4 key IO devices that we will concern ourselves with are:      1. Display: out device through which computer talks back with the user.     2. Keyboard/mouse: input device through which computer listens to the user     3. Storage device: This is the long term storage that computer has. All programs initially lies here.   </p> <p>Main memory is the area where program is loaded when it is to be run and it stays there while it\"s being executed. Think of it like short term memory in humans. Any task in ordered to be done should inside our memory.</p> <p>Processor is where results and addresses are computed in the program. It has 3 main parts: 1. Program counter 2. registers  3. ALU(Arithmetic and Logical unit)   </p>"},{"location":"lectures/Lecture3_4/#memory-hierarchy","title":"Memory hierarchy","text":""},{"location":"lectures/Lecture3_4/#storage-devices","title":"Storage devices","text":"<ol> <li>Random Access Memory<ol> <li>Static RAM(SRAM) is used for cache memories, both on and off the CPU chip.</li> <li>DRAM(Dynamic RAM) is used for the main memory plus the frame buffer of a graphics system.</li> </ol> </li> <li>HDD(Magnetic Storage) use spinning magnetic platters to store data. A read/write head moves over the platters to read or write data. </li> <li>Solid state disks(SSD) store data on interconnected flash memory chips that retain data even when powered off. </li> </ol>"},{"location":"lectures/Lecture3_4/#memory-hierarchy-and-cache","title":"Memory hierarchy and Cache","text":"<p>The storage devices in every computer system are organised as a memory hierarchy. As we move from the top of the hierarchy to the bottom, the devices become slower, larger, and less costly per byte.</p> <p>The main idea of a memory hierarchy is that storage at one level serves as a cache for storage at the next lower level. Thus, the register \ufb01le is a cache for the L1 cache. Caches L1 and L2 are caches for L2 and L3, respectively. The L3 cache is a cache for the main memory, which is a cache for the disk. <pre><code>lscpu | grep cache;getconf -a | grep CACHE\n</code></pre></p> <p> Image credits: CSAPP</p>"},{"location":"lectures/Lecture3_4/#caching","title":"Caching","text":"<ul> <li>Hardware : Registers, L1, L2, L3  act as cache for main memory.   </li> <li>Operating system: Main memory acts as cache for disc while implementing virtual memory.  </li> <li>Application programs: Browser cache recently accessed web pages for faster loading. </li> </ul>"},{"location":"lectures/Lecture3_4/#locality-principles","title":"Locality principles","text":"<p>Cache leads to improved performance because of following principles:</p> <p>Temporal locality:  a memory location that is referenced once is likely to be referenced again multiple times in the near future. Spatial locality:  if a memory location is referenced once, then the program is likely to reference a nearby memory location in the near future.</p>"},{"location":"lectures/Lecture3_4/#relative-latencies","title":"Relative latencies","text":"<p> Image credits:  relative-time-latencies-and-computer-programming</p>"},{"location":"lectures/Lecture3_4/#disk-access","title":"Disk access","text":"<p>HDD VS SSD</p> <p> Image credits: Backblaze</p> <p>Total Read Time = Seek time  + Rotational latency (HDD only)  + Transfer time (sequential read)</p>"},{"location":"lectures/Lecture3_4/#hdd-vs-ssd","title":"HDD vs SSD","text":"Pattern HDD SSD Sequential read Excellent Excellent Random read Terrible Acceptable Seek cost Dominant None Throughput High if sequential High Latency variance Huge Small"},{"location":"lectures/Lecture3_4/#log-based-storage","title":"Log based storage","text":"<p>A log is an append-only sequence of records. It doesn\u2019t have to be human-readable; it might be binary and intended only for other programs to read.</p> <pre><code>#!/bin/bash\ndb_set () {\n    echo \"$1,$2\" &gt;&gt; database\n}\n\ndb_get () {\n    grep \"^$1,\" database | sed -e \"s/^$1,//\" | tail -n 1\n}\n</code></pre> Pros Cons - Faster writes since appending to a file is a cheap operation - Read complexity is O(n) since each read requires us to read the whole file"},{"location":"lectures/Lecture3_4/#log-based-storage-hash-indexes","title":"Log based storage + hash indexes","text":"<p>Key idea: Along with appending to the log file maintain a in-memory hashmap that acts as a signpost to the actual keys.</p> <p> Image credits: Designing Data-Intensive Applications</p>"},{"location":"lectures/Lecture3_4/#implementation-details","title":"Implementation details:","text":"<ul> <li>How do we avoid running out of disk space?:   via compaction: Process of timely removing the duplicates from segment file. </li> <li>File format: CSV is not the best format for a log. It\u2019s faster and simpler to use a binary format that first encodes the length of a string in bytes, followed by the raw string (without need for escaping).</li> <li>How to delete record? If you want to delete a key and its associated value, you have to append a special deletion record to the data file (sometimes called a tombstone). When log segments are merged, the tombstone tells the merging process to discard any previous values for the deleted key.</li> <li>Crash recovery:<ul> <li>Read all segment and regenerate hash map on service restart(painful if we have large segment files)</li> <li>Maintain hashmap on disk also and read it into memory on restart.</li> </ul> </li> <li>Concurrency: One write thread, multiple read thread</li> </ul>"},{"location":"lectures/Lecture3_4/#tradeoffs","title":"Tradeoffs","text":"<p>Pros:</p> <ul> <li>Appending and segment merging are sequential write operations, which are generally much faster than random writes, especially on magnetic spinning-disk hard drives.  </li> <li>Concurrency and crash recovery are much simpler if segment files are append-only or immutable.  </li> <li>Merging old segments avoids the problem of data files getting fragmented over time  </li> </ul> <p>Cons:</p> <ul> <li>Hash table must fit into main memory. so if you have a very large number of keys, you\u2019re out of luck.  </li> <li>Range queries are not efficient. For example, you cannot easily scan over all keys between kitty00000 and kitty99999\u2014you\u2019d have to look up each key individu\u2010 ally in the hash maps.  </li> </ul>"},{"location":"lectures/Lecture3_4/#references","title":"References","text":"<ol> <li>Chapter 1, Computer Systems: A Programmer's Perspective(CSAPP)</li> <li>Chapter 3, Designing Data intensive Applications</li> <li>Bitcask - A Log-Structured fast KV store</li> </ol>"}]}